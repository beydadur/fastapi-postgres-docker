apiVersion: v1
data:
  db.py: |
    from sqlalchemy import create_engine
    from sqlalchemy.orm import sessionmaker, DeclarativeBase

    import os

    DATABASE_URL = os.getenv("DATABASE_URL", "postgresql+psycopg://appuser:apppass@db:5432/appdb")

    class Base(DeclarativeBase):
        pass

    engine = create_engine(DATABASE_URL, pool_pre_ping=True)
    SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)
  main.py: |-
    import fastapi as fastapi
    from typing import TYPE_CHECKING, List
    import sqlalchemy.orm as orm

    from . import models, schemas, services
    from . import db as database

    if TYPE_CHECKING:
        from sqlalchemy.orm import Session

    app = fastapi.FastAPI()

    @app.on_event("startup")
    def on_startup():
        services._add_tables()

    @app.post("/api/items/", response_model=schemas.Item)
    async def create_item(item: schemas.CreateItem, db_session: "Session" = fastapi.Depends(services.get_db)):
        return await services.create_item(item=item, db_session=db_session)

    @app.get("/api/items/", response_model=List[schemas.Item])
    async def read_items(skip: int = 0, limit: int = 100, db_session: "Session" = fastapi.Depends(services.get_db)):
        items = await services.get_all_items(db_session=db_session, skip=skip, limit=limit)
        return items

    @app.get("/api/items/{item_id}", response_model=schemas.Item)
    async def read_item(item_id: int, db_session: "Session" = fastapi.Depends(services.get_db)):
        db_item = await services.get_item(db_session=db_session, item_id=item_id)
        if db_item is None:
            raise fastapi.HTTPException(status_code=404, detail="Item not found")
        return db_item

    @app.delete("/api/items/{item_id}", response_model=schemas.Item)
    async def delete_item(item_id: int, db_session: "Session" = fastapi.Depends(services.get_db)):
        db_item = await services.delete_item(db_session=db_session, item_id=item_id)
        if db_item is None:
            raise fastapi.HTTPException(status_code=404, detail="Item not found")
        return db_item

    @app.put("/api/items/{item_id}", response_model=schemas.Item)
    async def update_item(item_id: int, item: schemas.CreateItem, db_session: "Session" = fastapi.Depends(services.get_db)):
        db_item = await services.update_item(db_session=db_session, item_id=item_id, item=item)
        if db_item is None:
            raise fastapi.HTTPException(status_code=404, detail="Item not found")
        return db_item
  models.py: |
    import datetime as _dt
    import sqlalchemy as _sql
    from . import db as _database

    class Item(_database.Base):
        __tablename__ = "items"
        id = _sql.Column(_sql.Integer, primary_key=True, index=True)
        title = _sql.Column(_sql.String, index=True)
        description = _sql.Column(_sql.String, index=True)
        price = _sql.Column(_sql.Float, index=True)
        created_at = _sql.Column(_sql.DateTime, default=_dt.datetime.utcnow)
  requirements-test.txt: |
    -r requirements.txt
    pytest
    httpx
  requirements.txt: |
    fastapi==0.115.4
    uvicorn[standard]==0.30.6
    SQLAlchemy==2.0.36
    psycopg[binary]==3.2.3
    pydantic==2.9.2
  schemas.py: |-
    import datetime as _dt
    import pydantic as _pydantic
    import typing as _typing

    class _ItemBase(_pydantic.BaseModel):
        title: str
        description: str
        price: float

    class Item(_ItemBase):
        id: int
        created_at: _dt.datetime

        class Config:
            from_attributes = True

    class CreateItem(_ItemBase):
        pass
  services.py: |-
    from typing import TYPE_CHECKING, List

    from . import db
    from . import models
    from . import schemas

    if TYPE_CHECKING:
        from sqlalchemy.orm import Session

    def _add_tables():
            return db.Base.metadata.create_all(bind=db.engine)

    def get_db():
        db_session = db.SessionLocal()
        try:
            yield db_session
        finally:
            db_session.close()

    async def create_item(item: schemas.CreateItem, db_session: "Session") -> schemas.Item:
        db_item = models.Item(**item.dict())
        db_session.add(db_item)
        db_session.commit()
        db_session.refresh(db_item)
        return schemas.Item.from_orm(db_item)

    async def get_all_items(db_session: "Session", skip: int = 0, limit: int = 100) -> List[schemas.Item]:
        items = db_session.query(models.Item).offset(skip).limit(limit).all()
        return [ schemas.Item.from_orm(item) for item in items ]

    async def get_item(db_session: "Session", item_id: int) -> schemas.Item | None:
        item = db_session.query(models.Item).filter(models.Item.id == item_id).first()
        if item:
            return schemas.Item.from_orm(item)
        return None

    async def delete_item(db_session: "Session", item_id: int) -> schemas.Item | None:
        item = db_session.query(models.Item).filter(models.Item.id == item_id).first()
        if item:
            db_session.delete(item)
            db_session.commit()
            return schemas.Item.from_orm(item)
        return None

    async def update_item(db_session: "Session", item_id: int, item: schemas.CreateItem) -> schemas.Item | None:
        db_item = db_session.query(models.Item).filter(models.Item.id == item_id).first()
        if db_item:
            for key, value in item.dict().items():
                setattr(db_item, key, value)
            db_session.commit()
            db_session.refresh(db_item)
            return schemas.Item.from_orm(db_item)
        return None
kind: ConfigMap
metadata:
  labels:
    io.kompose.service: api
  name: api-cm0

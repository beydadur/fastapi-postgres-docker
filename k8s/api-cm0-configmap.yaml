apiVersion: v1
data:
  index.html: |
    <!DOCTYPE html>
    <html lang="tr">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Welcome to FastAPI Project</title>
        <style>
            body { 
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
                display: flex; 
                justify-content: center; 
                align-items: center; 
                height: 100vh; 
                margin: 0; 
                background-color: #f4f7f6;
            }
            .container { 
                text-align: center; 
                padding: 40px; 
                background-color: #ffffff; 
                border-radius: 10px; 
                box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            }
            h1 { 
                color: #00796b; /* FastAPI ye≈üili */
                margin-bottom: 20px;
            }
            p { 
                font-size: 1.1em; 
                color: #333;
            }
            a { 
                color: #00796b; 
                text-decoration: none; 
                font-weight: bold; 
                border-bottom: 2px solid #b2dfdb;
                transition: all 0.3s ease;
            }
            a:hover {
                background-color: #e0f2f1;
                border-bottom-color: #00796b;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>FastAPI, Docker & Kubernetes Project</h1>
            <p>API documentation can be found at <a href="/docs">/docs</a>.</p>
        </div>
    </body>
    </html>
  db.py: |
    from sqlalchemy import create_engine
    from sqlalchemy.orm import sessionmaker, DeclarativeBase

    import os

    DATABASE_URL = os.getenv("DATABASE_URL", "postgresql+psycopg://appuser:apppass@db:5432/appdb")

    class Base(DeclarativeBase):
        pass

    engine = create_engine(DATABASE_URL, pool_pre_ping=True)
    SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)
  main.py: |-
    import fastapi as fastapi
    from typing import TYPE_CHECKING, List
    import sqlalchemy.orm as orm
    from fastapi.responses import FileResponse
    import os
    from pathlib import Path

    from . import models, schemas, services
    from . import db as database

    if TYPE_CHECKING:
        from sqlalchemy.orm import Session

    BASE_DIR = Path(__file__).resolve().parent

    app = fastapi.FastAPI()

    @app.on_event("startup")
    def on_startup():
        services._add_tables()

    @app.get("/", response_class=FileResponse)
    async def read_root():
        return FileResponse(BASE_DIR / "index.html")

    @app.post("/api/items/", response_model=schemas.Item)
    async def create_item(item: schemas.CreateItem, db_session: "Session" = fastapi.Depends(services.get_db)):
        return await services.create_item(item=item, db_session=db_session)

    @app.get("/api/items/", response_model=List[schemas.Item])
    async def read_items(skip: int = 0, limit: int = 100, db_session: "Session" = fastapi.Depends(services.get_db)):
        items = await services.get_all_items(db_session=db_session, skip=skip, limit=limit)
        return items

    @app.get("/api/items/{item_id}", response_model=schemas.Item)
    async def read_item(item_id: int, db_session: "Session" = fastapi.Depends(services.get_db)):
        db_item = await services.get_item(db_session=db_session, item_id=item_id)
        if db_item is None:
            raise fastapi.HTTPException(status_code=404, detail="Item not found")
        return db_item

    @app.delete("/api/items/{item_id}", response_model=schemas.Item)
    async def delete_item(item_id: int, db_session: "Session" = fastapi.Depends(services.get_db)):
        db_item = await services.delete_item(db_session=db_session, item_id=item_id)
        if db_item is None:
            raise fastapi.HTTPException(status_code=404, detail="Item not found")
        return db_item

    @app.put("/api/items/{item_id}", response_model=schemas.Item)
    async def update_item(item_id: int, item: schemas.CreateItem, db_session: "Session" = fastapi.Depends(services.get_db)):
        db_item = await services.update_item(db_session=db_session, item_id=item_id, item=item)
        if db_item is None:
            raise fastapi.HTTPException(status_code=404, detail="Item not found")
        return db_item
  models.py: |
    import datetime as _dt
    import sqlalchemy as _sql
    from . import db as _database

    class Item(_database.Base):
        __tablename__ = "items"
        id = _sql.Column(_sql.Integer, primary_key=True, index=True)
        title = _sql.Column(_sql.String, index=True)
        description = _sql.Column(_sql.String, index=True)
        price = _sql.Column(_sql.Float, index=True)
        created_at = _sql.Column(_sql.DateTime, default=_dt.datetime.utcnow)
  requirements-test.txt: |
    -r requirements.txt
    pytest
    httpx
  requirements.txt: |
    fastapi==0.115.4
    uvicorn[standard]==0.30.6
    SQLAlchemy==2.0.36
    psycopg[binary]==3.2.3
    pydantic==2.9.2
  schemas.py: |-
    import datetime as _dt
    import pydantic as _pydantic
    import typing as _typing

    class _ItemBase(_pydantic.BaseModel):
        title: str
        description: str
        price: float

    class Item(_ItemBase):
        id: int
        created_at: _dt.datetime

        class Config:
            from_attributes = True

    class CreateItem(_ItemBase):
        pass
  services.py: |-
    from typing import TYPE_CHECKING, List

    from . import db
    from . import models
    from . import schemas

    if TYPE_CHECKING:
        from sqlalchemy.orm import Session

    def _add_tables():
            return db.Base.metadata.create_all(bind=db.engine)

    def get_db():
        db_session = db.SessionLocal()
        try:
            yield db_session
        finally:
            db_session.close()

    async def create_item(item: schemas.CreateItem, db_session: "Session") -> schemas.Item:
        db_item = models.Item(**item.dict())
        db_session.add(db_item)
        db_session.commit()
        db_session.refresh(db_item)
        return schemas.Item.from_orm(db_item)

    async def get_all_items(db_session: "Session", skip: int = 0, limit: int = 100) -> List[schemas.Item]:
        items = db_session.query(models.Item).offset(skip).limit(limit).all()
        return [ schemas.Item.from_orm(item) for item in items ]

    async def get_item(db_session: "Session", item_id: int) -> schemas.Item | None:
        item = db_session.query(models.Item).filter(models.Item.id == item_id).first()
        if item:
            return schemas.Item.from_orm(item)
        return None

    async def delete_item(db_session: "Session", item_id: int) -> schemas.Item | None:
        item = db_session.query(models.Item).filter(models.Item.id == item_id).first()
        if item:
            db_session.delete(item)
            db_session.commit()
            return schemas.Item.from_orm(item)
        return None

    async def update_item(db_session: "Session", item_id: int, item: schemas.CreateItem) -> schemas.Item | None:
        db_item = db_session.query(models.Item).filter(models.Item.id == item_id).first()
        if db_item:
            for key, value in item.dict().items():
                setattr(db_item, key, value)
            db_session.commit()
            db_session.refresh(db_item)
            return schemas.Item.from_orm(db_item)
        return None
kind: ConfigMap
metadata:
  labels:
    io.kompose.service: api
  name: api-cm0
